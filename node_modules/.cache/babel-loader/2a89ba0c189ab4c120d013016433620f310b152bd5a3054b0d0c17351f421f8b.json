{"ast":null,"code":"import { coinFlip, interpolateTrig, randRange } from '../../../utils/functions';\nimport { complex, sqrt, exp, sin, cos, add, subtract, multiply, divide, asin } from 'mathjs';\nimport { atan, acos, pow } from 'mathjs';\nimport { interpolateColor, themeTransientCycle, WHITE } from '../../../utils/colors';\nimport { getLaguerrePolynomial, getLegendrePolynomial, getSphericalHarmonic } from './atom.rs';\nconst A0 = 0.25;\nclass Particle {\n  constructor(x, y, z) {\n    this.x = x;\n    this.y = y;\n    this.z = z;\n    this.color = WHITE;\n    this.buffer = [];\n  }\n  move(dx, dy, dz, addToPlayback) {\n    if (addToPlayback) {\n      this.buffer.push({\n        x: this.x,\n        y: this.y,\n        z: this.z,\n        color: themeTransientCycle(WHITE, WHITE, (1 + Math.sin(Math.atan(this.y / this.x) / 2)) / 2, interpolateTrig)\n      });\n    }\n    this.x += dx;\n    this.y += dy;\n    this.z += dz;\n  }\n  playback(history) {\n    this.set(this.buffer[history].x, this.buffer[history].y, this.buffer[history].z);\n    this.setColor(this.buffer[history].color);\n  }\n  set(dx, dy, dz) {\n    this.x = dx;\n    this.y = dy;\n    this.z = dz;\n  }\n  setColor(color) {\n    this.color = color;\n  }\n}\nconst Atom = class {\n  constructor(props) {\n    this.superposition = props.superposition;\n    this.particleCount = props.particleCount;\n    this.boxSize = props.boxSize;\n    this.timer = 0;\n    this.playbackTimer = -2500;\n    this.particles = [];\n    while (this.particles.length < props.particleCount) {\n      var theta = randRange(0, Math.PI * 2);\n      var phi = asin(randRange(-1, 1));\n      var radius = 1 / randRange(0.5, 2);\n      var newParticle = new Particle(radius * cos(theta) * cos(phi), radius * cos(theta) * sin(phi), radius * sin(theta));\n      if (coinFlip(100000 * this.getProbabilityDistribution(newParticle.x, newParticle.y, newParticle.z, 0))) {\n        this.particles.push(newParticle);\n      }\n    }\n  }\n  getWavefunction(x, y, z, t) {\n    var total = 0;\n    for (var i = 0; i < this.superposition.length; i++) {\n      var phase = exp(complex(0, getEnergyLevel(this.superposition[i].n) * t));\n      total = add(total, multiply(phase, this.superposition[i].weight, getFunctional(this.superposition[i].n, this.superposition[i].l, this.superposition[i].m)(x, y, z)));\n    }\n    return total;\n  }\n  getProbabilityDistribution(x, y, z, t) {\n    var wavefunction = this.getWavefunction(x, y, z, t);\n    var wavefunctionC = wavefunction.conjugate();\n    return multiply(wavefunction, wavefunctionC);\n  }\n  getWavefunctionGradient(x, y, z, t) {\n    var total = [complex(0, 0), complex(0, 0), complex(0, 0)];\n    for (var i = 0; i < this.superposition.length; i++) {\n      var phase = exp(complex(0, getEnergyLevel(this.superposition[i].n) * t));\n      var grad = getGradient(this.superposition[i].n, this.superposition[i].l, this.superposition[i].m, this.timer)(x, y, z, t);\n      total[0] = add(total[0], multiply(phase, this.superposition[i].weight, grad[0]));\n      total[1] = add(total[1], multiply(phase, this.superposition[i].weight, grad[1]));\n      total[2] = add(total[2], multiply(phase, this.superposition[i].weight, grad[2]));\n    }\n    return total;\n  }\n  getVelocity(x, y, z, t) {\n    var wavefunction = this.getWavefunction(x, y, z, t);\n    var wavefunctionC = wavefunction.conjugate();\n    var gradient = this.getWavefunctionGradient(x, y, z, t);\n    var gradientC = [gradient[0].conjugate(), gradient[1].conjugate(), gradient[2].conjugate()];\n    var velocity = [divide(subtract(multiply(wavefunctionC, gradient[0]), multiply(wavefunction, gradientC[0])), add(1e-8, multiply(wavefunction, wavefunctionC))), divide(subtract(multiply(wavefunctionC, gradient[1]), multiply(wavefunction, gradientC[1])), add(1e-8, multiply(wavefunction, wavefunctionC))), divide(subtract(multiply(wavefunctionC, gradient[2]), multiply(wavefunction, gradientC[2])), add(1e-8, multiply(wavefunction, wavefunctionC)))];\n    return velocity;\n  }\n  update(increment) {\n    var deltat = 0.0075;\n    if (this.playbackTimer < 0) {\n      for (var i = 0; i < this.particles.length; i++) {\n        var p = this.particles[i];\n        var oldNorm = Math.sqrt(p.x * p.x + p.y * p.y + p.z * p.z);\n        for (var j = 0; j < 1; j++) {\n          var velocity = this.getVelocity(p.x, p.y, p.z, this.timer);\n          var t = 1 - sin(atan(velocity[1].im / velocity[0].im) / 2) / 2;\n          p.setColor(themeTransientCycle(WHITE, WHITE, t, interpolateTrig));\n          p.move(velocity[0].im * deltat, velocity[1].im * deltat, velocity[2].im * deltat, false);\n        }\n        var newNorm = Math.sqrt(p.x * p.x + p.y * p.y + p.z * p.z);\n        var factor = (oldNorm - newNorm) / newNorm * 0.05;\n        p.move(p.x * factor, p.y * factor, p.z * factor, true);\n      }\n      console.log(this.playbackTimer);\n    } else {\n      for (var i = 0; i < this.particles.length; i++) {\n        var p = this.particles[i];\n        p.setColor(p.buffer[this.playbackTimer].color);\n        p.playback(this.playbackTimer);\n      }\n    }\n    this.playbackTimer += 1;\n    if (this.playbackTimer == 2500) {\n      this.playbackTimer = 0;\n    }\n    this.timer += deltat * 5;\n    return this;\n  }\n};\nexport default Atom;","map":{"version":3,"names":["coinFlip","interpolateTrig","randRange","complex","sqrt","exp","sin","cos","add","subtract","multiply","divide","asin","atan","acos","pow","interpolateColor","themeTransientCycle","WHITE","getLaguerrePolynomial","getLegendrePolynomial","getSphericalHarmonic","A0","Particle","constructor","x","y","z","color","buffer","move","dx","dy","dz","addToPlayback","push","Math","playback","history","set","setColor","Atom","props","superposition","particleCount","boxSize","timer","playbackTimer","particles","length","theta","PI","phi","radius","newParticle","getProbabilityDistribution","getWavefunction","t","total","i","phase","getEnergyLevel","n","weight","getFunctional","l","m","wavefunction","wavefunctionC","conjugate","getWavefunctionGradient","grad","getGradient","getVelocity","gradient","gradientC","velocity","update","increment","deltat","p","oldNorm","j","im","newNorm","factor","console","log"],"sources":["/Users/joeyzhu/Projects/joey-j-zhu.github.io/src/components/fold/fold-graphics/atom.js"],"sourcesContent":["import { coinFlip, \n    interpolateTrig, \n    randRange, \n  } from '../../../utils/functions';\nimport { complex, sqrt, exp, sin, cos, add, subtract, multiply, divide, asin } from 'mathjs';\nimport { atan, acos, pow } from 'mathjs';\nimport { interpolateColor, themeTransientCycle, WHITE } from '../../../utils/colors';\nimport { getLaguerrePolynomial, getLegendrePolynomial, getSphericalHarmonic } from './atom.rs';\n\nconst A0 = 0.25;\n\nclass Particle {\n    constructor(x, y, z) {\n        this.x = x;\n        this.y = y;\n        this.z = z;\n        this.color = WHITE;\n        this.buffer = [];\n    }\n\n    move(dx, dy, dz, addToPlayback) {\n        if (addToPlayback) {\n            this.buffer.push({x: this.x, y: this.y, z: this.z, color: themeTransientCycle(WHITE, WHITE, (1 + Math.sin(Math.atan(this.y / this.x) / 2)) / 2, interpolateTrig)});\n        }\n        this.x += dx;\n        this.y += dy;\n        this.z += dz;\n    }\n\n    playback(history) {\n        this.set(this.buffer[history].x, this.buffer[history].y, this.buffer[history].z);\n        this.setColor(this.buffer[history].color);\n    }\n\n    set(dx, dy, dz) {\n        this.x = dx;\n        this.y = dy;\n        this.z = dz;\n    }\n\n    setColor(color) {\n        this.color = color;\n    }\n}\n\n\nconst Atom = class {\n    constructor (props) {\n        this.superposition = props.superposition;\n        this.particleCount = props.particleCount;\n        this.boxSize = props.boxSize;\n        this.timer = 0;\n        this.playbackTimer = -2500;\n\n        this.particles = [];\n        \n        while (this.particles.length < props.particleCount) {\n            var theta = randRange(0, Math.PI * 2);\n            var phi = asin(randRange(-1, 1));\n            var radius = 1 / randRange(0.5, 2);\n            var newParticle = new Particle(\n                radius * cos(theta) * cos(phi),\n                radius * cos(theta) * sin(phi),\n                radius * sin(theta),\n            );\n            if (coinFlip(100000 * this.getProbabilityDistribution(newParticle.x, newParticle.y, newParticle.z, 0))) {\n                this.particles.push(newParticle);\n            }\n        }\n    }\n\n    getWavefunction(x, y, z, t) {\n        var total = 0;\n        for (var i = 0; i < this.superposition.length; i++) {\n            var phase = exp(complex(0, getEnergyLevel(this.superposition[i].n) * t));\n            total = add(total, multiply(phase, this.superposition[i].weight, getFunctional(this.superposition[i].n, this.superposition[i].l, this.superposition[i].m)(x, y, z)));\n        }\n\n        return total;\n    }\n\n    getProbabilityDistribution(x, y, z, t) {\n        var wavefunction = this.getWavefunction(x, y, z, t);\n        var wavefunctionC = wavefunction.conjugate();\n        return multiply(wavefunction, wavefunctionC);    \n    }\n\n    getWavefunctionGradient(x, y, z, t) {\n        var total = [complex(0, 0), complex(0, 0), complex(0, 0)];\n        for (var i = 0; i < this.superposition.length; i++) {\n            var phase = exp(complex(0, getEnergyLevel(this.superposition[i].n) * t));\n            var grad = getGradient(this.superposition[i].n, this.superposition[i].l, this.superposition[i].m, this.timer)(x, y, z, t);\n            total[0] = add(total[0], multiply(phase, this.superposition[i].weight, grad[0]));\n            total[1] = add(total[1], multiply(phase, this.superposition[i].weight, grad[1]));\n            total[2] = add(total[2], multiply(phase, this.superposition[i].weight, grad[2]));\n        }\n        return total;\n    }\n    \n    getVelocity(x, y, z, t) {\n        var wavefunction = this.getWavefunction(x, y, z, t);\n        var wavefunctionC = wavefunction.conjugate();\n        var gradient = this.getWavefunctionGradient(x, y, z, t);\n        var gradientC = [\n            gradient[0].conjugate(), \n            gradient[1].conjugate(), \n            gradient[2].conjugate(), \n        ];\n        var velocity = [\n            divide(subtract(multiply(wavefunctionC, gradient[0]), multiply(wavefunction, gradientC[0])), add(1e-8, multiply(wavefunction, wavefunctionC))),\n            divide(subtract(multiply(wavefunctionC, gradient[1]), multiply(wavefunction, gradientC[1])), add(1e-8, multiply(wavefunction, wavefunctionC))),\n            divide(subtract(multiply(wavefunctionC, gradient[2]), multiply(wavefunction, gradientC[2])), add(1e-8, multiply(wavefunction, wavefunctionC)))\n        ];\n        return velocity;\n    }\n\n    update(increment) {\n        var deltat = 0.0075;\n        if (this.playbackTimer < 0) {\n            for (var i = 0; i < this.particles.length; i++) {\n                var p = this.particles[i];\n                var oldNorm = Math.sqrt(p.x * p.x + p.y * p.y + p.z * p.z);\n                for (var j = 0; j < 1; j++) {\n                    var velocity = this.getVelocity(p.x, p.y, p.z, this.timer);\n                    var t = 1 - sin(atan(velocity[1].im / velocity[0].im) / 2) / 2;\n                    p.setColor(themeTransientCycle(WHITE, WHITE, t, interpolateTrig));\n                    p.move(velocity[0].im * deltat, velocity[1].im * deltat, velocity[2].im * deltat, false);\n                }\n                var newNorm = Math.sqrt(p.x * p.x + p.y * p.y + p.z * p.z);\n                var factor = ((oldNorm - newNorm) / newNorm) * 0.05;\n                p.move(p.x * factor, p.y * factor, p.z * factor, true);\n            }\n            console.log(this.playbackTimer);\n        } else {\n            for (var i = 0; i < this.particles.length; i++) {\n                var p = this.particles[i];\n                p.setColor(p.buffer[this.playbackTimer].color);\n                p.playback(this.playbackTimer);\n            }\n        }\n        this.playbackTimer += 1;\n        if (this.playbackTimer == 2500) {\n            this.playbackTimer = 0;\n        }\n        this.timer += deltat * 5;\n        return this;\n    }\n}\n\nexport default Atom;"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}